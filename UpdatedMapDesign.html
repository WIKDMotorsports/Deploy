<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dyno Chart</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* * NOTE: The black background is a temporary placeholder.
         * This chart is intended to be placed within a glassmorphic
         * card, so the final implementation will not have a solid background.
         */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Black background for reference */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            padding: 2rem;
            box-sizing: border-box;
        }
        #chart-container {
            position: relative; /* This is required for positioning the overlay canvas */
            width: 100%;
            max-width: 900px;
        }
    </style>
</head>
<body>

    <!-- Chart Container -->
    <div id="chart-container">
        <canvas id="dynoChart"></canvas>
        <!-- The overlay canvas for animations will be created and added here by the script -->
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // --- DYNOGRAPH CHART DATA LOGIC (Unchanged) ---
        const fullChartData = [
            { rpm: 3000, horsepower: 380, torque: 670 }, { rpm: 3100, horsepower: 410, torque: 690 },
            { rpm: 3200, horsepower: 440, torque: 720 }, { rpm: 3300, horsepower: 480, torque: 760 },
            { rpm: 3400, horsepower: 530, torque: 815 }, { rpm: 3500, horsepower: 580, torque: 870 },
            { rpm: 3600, horsepower: 620, torque: 900 }, { rpm: 3700, horsepower: 650, torque: 920 },
            { rpm: 3800, horsepower: 670, torque: 925 }, { rpm: 3900, horsepower: 690, torque: 930 },
            { rpm: 4000, horsepower: 710, torque: 935 }, { rpm: 4100, horsepower: 735, torque: 940 },
            { rpm: 4200, horsepower: 760, torque: 950 }, { rpm: 4300, horsepower: 785, torque: 960 },
            { rpm: 4400, horsepower: 810, torque: 965 }, { rpm: 4500, horsepower: 830, torque: 970 },
            { rpm: 4600, horsepower: 855, torque: 975 }, { rpm: 4700, horsepower: 880, torque: 980 },
            { rpm: 4800, horsepower: 910, torque: 995 }, { rpm: 4900, horsepower: 940, torque: 1010 },
            { rpm: 5000, horsepower: 970, torque: 1020 }, { rpm: 5100, horsepower: 995, torque: 1025 },
            { rpm: 5200, horsepower: 1020, torque: 1030 }, { rpm: 5300, horsepower: 1050, torque: 1035 },
            { rpm: 5400, horsepower: 1080, torque: 1040 }, { rpm: 5500, horsepower: 1110, torque: 1045 },
            { rpm: 5600, horsepower: 1140, torque: 1045 },
            { rpm: 5700, horsepower: 1170, torque: 1040 }, { rpm: 5800, horsepower: 1200, torque: 1038 },
            { rpm: 5900, horsepower: 1225, torque: 1035 }, { rpm: 6000, horsepower: 1250, torque: 1030 },
            { rpm: 6100, horsepower: 1270, torque: 1025 }, { rpm: 6200, horsepower: 1285, torque: 1020 },
            { rpm: 6300, horsepower: 1300, torque: 1015 }, { rpm: 6400, horsepower: 1310, torque: 1010 },
            { rpm: 6500, horsepower: 1315, torque: 1005 },
            { rpm: 6600, horsepower: 1310, torque: 990 }, { rpm: 6700, horsepower: 1300, torque: 970 },
            { rpm: 6800, horsepower: 1280, torque: 930 }, { rpm: 6900, horsepower: 1150, torque: 820 },
        ];
        
        const lastRpmPoint = 6800;
        const chartData = fullChartData.filter(d => d.rpm <= lastRpmPoint);

        const peakHpIndex = chartData.findIndex(d => d.horsepower === 1315);
        const peakTqIndex = chartData.findIndex(d => d.torque === 1045);
        
        const peakHpData = new Array(chartData.length).fill(null);
        if (peakHpIndex !== -1) {
            peakHpData[peakHpIndex] = chartData[peakHpIndex].horsepower;
        }

        const peakTqData = new Array(chartData.length).fill(null);
        if (peakTqIndex !== -1) {
            peakTqData[peakTqIndex] = chartData[peakTqIndex].torque;
        }

        // --- CUSTOM PLUGIN FOR FULL BORDER (Unchanged) ---
        const fullBorderPlugin = {
            id: 'fullBorder',
            afterDraw: (chart) => {
                const { ctx, chartArea: { left, top, width, height } } = chart;
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.strokeRect(left, top, width, height);
                ctx.restore();
            }
        };

        const chartCanvas = document.getElementById('dynoChart');
        if (chartCanvas) {
            // --- OPTIMIZATION: SETUP OVERLAY CANVAS FOR ANIMATIONS ---
            const chartContainer = document.getElementById('chart-container');
            const overlayCanvas = document.createElement('canvas');
            overlayCanvas.style.position = 'absolute';
            overlayCanvas.style.top = '0';
            overlayCanvas.style.left = '0';
            overlayCanvas.style.pointerEvents = 'none'; // Makes the canvas transparent to mouse events
            chartContainer.appendChild(overlayCanvas);
            const overlayCtx = overlayCanvas.getContext('2d');

            // Animation state variables
            let hpPoint, tqPoint, hpPathPoints, tqPathPoints;

            // This function syncs the overlay canvas size and position with the main chart canvas.
            // It also recalculates the pixel coordinates of the peak points needed for the animation.
            function syncOverlay(chart) {
                overlayCanvas.width = chart.width;
                overlayCanvas.height = chart.height;
                overlayCanvas.style.width = chart.width + 'px';
                overlayCanvas.style.height = chart.height + 'px';

                const hpMeta = chart.getDatasetMeta(2);
                const tqMeta = chart.getDatasetMeta(3);
                
                if (peakHpIndex !== -1 && hpMeta.data[peakHpIndex]) {
                    hpPoint = hpMeta.data[peakHpIndex];
                    hpPathPoints = chart.getDatasetMeta(0).data.slice(0, peakHpIndex + 1);
                }
                if (peakTqIndex !== -1 && tqMeta.data[peakTqIndex]) {
                    tqPoint = tqMeta.data[peakTqIndex];
                    tqPathPoints = chart.getDatasetMeta(1).data.slice(0, peakTqIndex + 1);
                }
            }
            
            /**
             * Helper function to calculate a point along a path of {x,y} coordinates.
             * @param {Array} path - An array of point objects, e.g., [{x: 10, y: 20}, ...]
             * @param {number} progress - A value from 0 to 1 representing progress along the path.
             * @returns {object|null} - An object with {x, y} coordinates or null if path is invalid.
             */
            function getPointOnPath(path, progress) {
                if (!path || path.length < 2) return null;

                const lengths = [];
                let totalLength = 0;
                for (let i = 1; i < path.length; i++) {
                    const p1 = path[i-1];
                    const p2 = path[i];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    lengths.push(length);
                    totalLength += length;
                }

                const targetLength = totalLength * progress;
                let lengthTraversed = 0;

                for (let i = 0; i < lengths.length; i++) {
                    const segmentLength = lengths[i];
                    if (lengthTraversed + segmentLength >= targetLength) {
                        const p1 = path[i];
                        const p2 = path[i+1];
                        const segmentProgress = (targetLength - lengthTraversed) / segmentLength;
                        const x = p1.x + (p2.x - p1.x) * segmentProgress;
                        const y = p1.y + (p2.y - p1.y) * segmentProgress;
                        return { x, y };
                    }
                    lengthTraversed += segmentLength;
                }
                // If progress is 1 or beyond, return the last point
                return { x: path[path.length - 1].x, y: path[path.length - 1].y };
            }

            const chart = new Chart(chartCanvas, {
                type: 'line',
                data: {
                    labels: chartData.map(d => d.rpm),
                    datasets: [
                        {
                            label: 'Horsepower (WHP)',
                            data: chartData.map(d => d.horsepower),
                            borderColor: '#ff4747',
                            backgroundColor: '#ff4747',
                            borderWidth: 2,
                            pointRadius: 0,
                            pointStyle: 'triangle',
                            yAxisID: 'yHP',
                            tension: 0.4,
                            order: 1,
                            segment: {
                                borderColor: ctx => (peakHpIndex !== -1 && ctx.p1DataIndex > peakHpIndex) ? '#555555' : undefined,
                                borderDash: ctx => (peakHpIndex !== -1 && ctx.p1DataIndex > peakHpIndex) ? [5, 5] : undefined,
                            }
                        },
                        {
                            label: 'Torque (lb-ft)',
                            data: chartData.map(d => d.torque),
                            borderColor: '#ffa500',
                            backgroundColor: '#ffa500',
                            borderWidth: 2,
                            pointRadius: 0,
                            pointStyle: 'rect',
                            yAxisID: 'yHP',
                            tension: 0.4,
                            order: 1,
                            segment: {
                                borderColor: ctx => (peakTqIndex !== -1 && ctx.p1DataIndex > peakTqIndex) ? '#555555' : undefined,
                                borderDash: ctx => (peakTqIndex !== -1 && ctx.p1DataIndex > peakTqIndex) ? [5, 5] : undefined,
                            }
                        },
                        {
                            label: 'Peak HP',
                            data: peakHpData,
                            pointStyle: 'triangle',
                            pointRadius: 6,
                            pointBackgroundColor: '#ff4747',
                            yAxisID: 'yHP',
                            showLine: false,
                            order: 0,
                        },
                        {
                            label: 'Peak TQ',
                            data: peakTqData,
                            pointStyle: 'rect',
                            pointRadius: 6,
                            pointBackgroundColor: '#ffa500',
                            yAxisID: 'yHP',
                            showLine: false,
                            order: 0,
                        }
                    ]
                },
                options: {
                    animation: {
                        onComplete: (animation) => {
                            const chartInstance = animation.chart;
                            syncOverlay(chartInstance); // Initial sync

                            // --- OPTIMIZATION: DECOUPLED PULSE & PING ANIMATION ---
                            // This animation runs on the overlay canvas and does not call chart.update(),
                            // preventing any performance conflict with tooltips or other interactions.
                            if (chartInstance.pingAnimationId) {
                                cancelAnimationFrame(chartInstance.pingAnimationId);
                            }

                            let startTime = 0;
                            const duration = 5000; // MODIFIED: Increased duration to slow down frequency
                            const waves = 3;
                            const maxRadius = 12;
                            const easeOutQuint = (t) => 1 - Math.pow(1 - t, 5);

                            function animatePing(timestamp) {
                                if (!startTime) startTime = timestamp;
                                const progress = ((timestamp - startTime) % duration) / duration;

                                overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                                overlayCtx.save();
                                
                                // --- NEW: PULSE ANIMATION ---
                                const hpPulsePos = getPointOnPath(hpPathPoints, progress);
                                const tqPulsePos = getPointOnPath(tqPathPoints, progress);

                                // Draw HP Pulse
                                if (hpPulsePos) {
                                    overlayCtx.beginPath();
                                    const hpGradient = overlayCtx.createRadialGradient(hpPulsePos.x, hpPulsePos.y, 0, hpPulsePos.x, hpPulsePos.y, 5);
                                    hpGradient.addColorStop(0, 'rgba(255, 71, 71, 0.7)');
                                    hpGradient.addColorStop(1, 'rgba(255, 71, 71, 0)');
                                    overlayCtx.fillStyle = hpGradient;
                                    overlayCtx.arc(hpPulsePos.x, hpPulsePos.y, 5, 0, 2 * Math.PI);
                                    overlayCtx.fill();
                                }

                                // Draw TQ Pulse
                                if (tqPulsePos) {
                                    overlayCtx.beginPath();
                                    const tqGradient = overlayCtx.createRadialGradient(tqPulsePos.x, tqPulsePos.y, 0, tqPulsePos.x, tqPulsePos.y, 5);
                                    tqGradient.addColorStop(0, 'rgba(255, 165, 0, 0.7)');
                                    tqGradient.addColorStop(1, 'rgba(255, 165, 0, 0)');
                                    overlayCtx.fillStyle = tqGradient;
                                    overlayCtx.arc(tqPulsePos.x, tqPulsePos.y, 5, 0, 2 * Math.PI);
                                    overlayCtx.fill();
                                }

                                // --- PING ANIMATION (Unchanged logic, but now synced with pulse) ---
                                overlayCtx.lineWidth = 2;
                                for (let i = 0; i < waves; i++) {
                                    const waveProgress = (progress - (i / waves) + 1) % 1;
                                    const easedProgress = easeOutQuint(waveProgress);
                                    const pingGap = maxRadius * easedProgress;
                                    const alpha = 1 - easedProgress;

                                    // Draw HP Ping (Triangle Outline)
                                    if (hpPoint && !hpPoint.hidden) {
                                        const markerCircumradius = hpPoint.options.radius;
                                        const pingCircumradius = markerCircumradius + pingGap;

                                        overlayCtx.strokeStyle = `rgba(255, 71, 71, ${alpha})`;
                                        overlayCtx.beginPath();
                                        const angle = -Math.PI / 2;
                                        overlayCtx.moveTo(hpPoint.x + pingCircumradius * Math.cos(angle), hpPoint.y + pingCircumradius * Math.sin(angle));
                                        overlayCtx.lineTo(hpPoint.x + pingCircumradius * Math.cos(angle + 2 * Math.PI / 3), hpPoint.y + pingCircumradius * Math.sin(angle + 2 * Math.PI / 3));
                                        overlayCtx.lineTo(hpPoint.x + pingCircumradius * Math.cos(angle + 4 * Math.PI / 3), hpPoint.y + pingCircumradius * Math.sin(angle + 4 * Math.PI / 3));
                                        overlayCtx.closePath();
                                        overlayCtx.stroke();
                                    }

                                    // Draw TQ Ping (Rectangle Outline)
                                    if (tqPoint && !tqPoint.hidden) {
                                        const scaledPingGap = pingGap * 0.60;
                                        const markerRadius = tqPoint.options.radius;
                                        const pingSideRadius = markerRadius + scaledPingGap;

                                        overlayCtx.strokeStyle = `rgba(255, 165, 0, ${alpha})`;
                                        const size = pingSideRadius * 2;
                                        overlayCtx.strokeRect(tqPoint.x - pingSideRadius, tqPoint.y - pingSideRadius, size, size);
                                    }
                                }
                                overlayCtx.restore();
                                chartInstance.pingAnimationId = requestAnimationFrame(animatePing);
                            }
                            animatePing(performance.now());
                        },
                        x: {
                            type: 'number', easing: 'linear', duration: 50, from: NaN,
                            delay(ctx) {
                                if (ctx.type !== 'data' || ctx.xStarted) { return 0; }
                                ctx.xStarted = true; return ctx.index * 50;
                            }
                        },
                        y: {
                            type: 'number', easing: 'linear', duration: 50,
                            from: (ctx) => {
                                if (ctx.index === 0) { return ctx.chart.scales.yHP.getBasePixel(); }
                                return ctx.chart.getDatasetMeta(ctx.datasetIndex).data[ctx.index - 1].getProps(['y'], true).y;
                            },
                            delay(ctx) {
                                if (ctx.type !== 'data' || ctx.yStarted) { return 0; }
                                ctx.yStarted = true; return ctx.index * 50;
                            }
                        }
                    },
                    onResize: (chart) => {
                        // Keep the overlay synced when the window or container is resized.
                        syncOverlay(chart);
                    },
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1.5,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: {
                            labels: { color: 'white', usePointStyle: true, filter: (legendItem) => !legendItem.text.includes('Peak') }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(31, 31, 31, 0.9)',
                            borderColor: '#2A2A2A',
                            borderWidth: 1,
                            titleFont: { weight: 'bold' },
                            bodySpacing: 4,
                            padding: 10,
                            callbacks: {
                                filter: function(tooltipItem, index, tooltipItems) {
                                    // This logic prevents the regular HP/TQ values from appearing in the tooltip
                                    // when the corresponding "Peak" value is also present for the same data point.
                                    const hasPeakHp = tooltipItems.some(item => item.datasetIndex === 2);
                                    const hasPeakTq = tooltipItems.some(item => item.datasetIndex === 3);
                                    
                                    const currentDatasetIndex = tooltipItem.datasetIndex;

                                    // If Peak HP is active, hide the regular Horsepower line's tooltip item.
                                    if (hasPeakHp && currentDatasetIndex === 0) {
                                        return false;
                                    }

                                    // If Peak TQ is active, hide the regular Torque line's tooltip item.
                                    if (hasPeakTq && currentDatasetIndex === 1) {
                                        return false;
                                    }

                                    return true;
                                },
                                title: (context) => `RPM: ${context[0].label}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)', tickColor: (context) => context.tick.label ? 'rgba(255, 255, 255, 0.1)' : 'transparent' },
                            max: lastRpmPoint,
                            ticks: {
                                color: '#a1a1aa',
                                callback: function(val) {
                                    const tickValue = this.getLabelForValue(val);
                                    const isLastTick = val === this.max;
                                    if (tickValue % 500 === 0 || isLastTick) { return `${tickValue / 1000}k`; }
                                    return '';
                                },
                                maxRotation: 0,
                                autoSkipPadding: 20
                            }
                        },
                        yHP: {
                            type: 'linear', position: 'left',
                            grid: { color: 'rgba(255, 255, 255, 0.1)', tickColor: (context) => context.tick.label ? 'rgba(255, 255, 255, 0.1)' : 'transparent' },
                            ticks: {
                                color: '#a1a1aa', stepSize: 25,
                                callback: function(value) {
                                    if (value % 200 === 0 || value === this.max || value === this.min) { return value; }
                                    return '';
                                }
                            },
                            title: { display: false },
                            min: 380,
                            max: 1400,
                        },
                        yTQ: {
                            display: false
                        }
                    }
                },
                plugins: [fullBorderPlugin]
            });
        }
    });
    </script>
</body>
</html>
