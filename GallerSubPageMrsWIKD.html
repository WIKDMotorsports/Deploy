<!DOCTYPE html>
<html class="scroll-smooth" lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>WIKD Build - MRS.WIKD</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com">
  </script>
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com" rel="preconnect"/>
  <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@600;700&amp;family=Inter:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>
  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
  <style>
   /* Custom styles to complement Tailwind */
    :root {
      --color-primary: #FF00A6; /* Main Pink */
      --color-secondary: #FF4DBC; /* Lighter Pink Accent */
      --color-text-main: #EAEAEA; /* White/Off-white text */
    }
    body {
      font-family: 'Inter', sans-serif;
      background-color: #0A0A0A;
      color: #EAEAEA;
    }
    .font-heading {
      font-family: 'Rajdhani', sans-serif;
    }
    .lava-gradient-text {
      background: linear-gradient(90deg, #b20074, #FF00A6, #FF4DBC, #FF00A6, #b20074);
      background-size: 300%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: lavaFlow 4s ease-in-out infinite;
    }
    .lava-gradient-bg {
      background: linear-gradient(90deg, #b20074, #FF00A6, #FF4DBC, #FF00A6, #b20074);
      background-size: 300%;
      animation: lavaFlow 4s ease-in-out infinite;
    }
    @keyframes lavaFlow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    /* --- CLIP PATHS --- */
    .clip-path-custom {
      clip-path: polygon(0 0, 100% 0, 100% 100%, 30px 100%, 0 97%);
    }
    .clip-path-data-section {
      clip-path: polygon(0 0, 100% 0, 100% 100%, 15px 100%, 0 95%);
    }

    /* -- THEME COLOR CORRECTION -- */
    *:focus-visible {
      outline: 2px solid var(--color-primary) !important;
      outline-offset: 2px;
    }
    .mods-list li::before, .mods-section ul li::before {
      content: 'â– ';
      color: var(--color-primary);
      margin-right: 0.75rem;
      font-size: 0.8em;
    }
    #chart-container {
      position: relative;
    }

    /* --- DESKTOP VERTICAL TICKER --- */
    .ticker-wrapper {
      position: relative;
      flex-shrink: 0;
      width: 100%;
      max-width: 40rem;
      height: 100vh;
      overflow-y: scroll;
      -ms-overflow-style: none; /* IE and Edge */
      scrollbar-width: none; /* Firefox */
    }
    .ticker-wrapper::-webkit-scrollbar {
      display: none; /* Chrome, Safari, and Opera */
    }
    .image-ticker-card {
      width: 100%;
      height: auto;
      margin-bottom: 2rem;
      border-radius: 0.5rem;
      overflow: hidden;
      cursor: pointer;
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    }
    .image-ticker-card img, .image-ticker-card video {
      width: 100%;
      height: auto;
      display: block;
      filter: grayscale(80%);
      transition: filter 0.3s ease-in-out;
    }
    .image-ticker-card:hover img, .image-ticker-card:hover video {
      filter: grayscale(0%);
    }
    .ticker-inner {
      display: flex;
      flex-direction: column;
      will-change: transform;
    }
    .gradient-overlay-top, .gradient-overlay-bottom {
      position: sticky;
      left: 0;
      width: 100%;
      height: 10rem;
      pointer-events: none;
      z-index: 10;
    }
    .gradient-overlay-top {
      top: 0;
      background: linear-gradient(to bottom, #0A0A0A, rgba(10, 10, 10, 0));
    }
    .gradient-overlay-bottom {
      bottom: 0;
      background: linear-gradient(to top, #0A0A0A, rgba(10, 10, 10, 0));
    }

    /* --- HERO & PARALLAX (Desktop Only) --- */
    .build-hero {
      position: relative;
      padding: 0;
      overflow: hidden;
    }
    .parallax-video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      mix-blend-mode: screen;
      opacity: 0.8;
      z-index: 2;
    }
    .build-hero::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 70%);
      z-index: 4;
    }
  </style>
 </head>
 <body class="overflow-x-hidden">
  <!-- MOBILE-ONLY: Horizontal Gallery Wrapper -->
  <div class="lg:hidden fixed top-0 left-0 w-full h-[45vh] z-10 overflow-hidden" id="mobileGalleryWrapper">
   <div class="flex h-full will-change-transform" id="mobileTickerInner">
    <!-- Mobile gallery items will be populated by JS -->
   </div>
   <div class="absolute bottom-0 left-0 w-full h-24 bg-gradient-to-t from-[#0A0A0A] to-transparent">
   </div>
  </div>
  <div class="build-hero">
   <!-- Parallax video will be hidden on mobile via JS -->
   <video autoplay="" class="parallax-video hidden lg:block" loop="" muted="" playsinline="">
    <source src="https://videos.pexels.com/video-files/4123548/4123548-hd.mp4" type="video/mp4"/>
   </video>
   <!-- Main Content Container -->
   <div class="relative z-10 flex flex-col lg:flex-row justify-end lg:justify-center items-end lg:items-center lg:min-h-screen lg:p-6 xl:p-24 lg:gap-8 xl:gap-12">
    <!-- DESKTOP-ONLY: Vertical Image Ticker -->
    <div class="ticker-wrapper hidden lg:block" id="tickerWrapper">
     <div class="gradient-overlay-top">
     </div>
     <div class="ticker-inner" id="tickerInner">
      <div class="image-ticker-card">
       <img alt="MRS WIKD Bentley Gallery Image 1" src="https://cdn.shopify.com/s/files/1/0671/4635/0805/files/IMG_6895.jpg?v=1755181327"/>
      </div>
      <div class="image-ticker-card">
       <img alt="MRS WIKD Bentley Gallery Image 2" src="https://cdn.shopify.com/s/files/1/0671/4635/0805/files/IMG_6896_1.jpg?v=1755200328"/>
      </div>
      <div class="image-ticker-card">
       <img alt="MRS WIKD Bentley Gallery Image 3" src="https://cdn.shopify.com/s/files/1/0671/4635/0805/files/IMG_6898_1.jpg?v=1755200326"/>
      </div>
     </div>
     <div class="gradient-overlay-bottom">
     </div>
    </div>
    <!-- Content Card -->
    <main class="relative z-20 w-full lg:w-3/4 xl:w-1/2 max-w-4xl bg-[#0A0A0A] lg:bg-black/75 border-t border-gray-800 lg:border-t-0 lg:border border-gray-800 shadow-2xl lg:clip-path-custom flex flex-col mt-[45vh] lg:mt-0" id="contentCard">
     <!-- Card Header -->
     <!-- FIX: Changed grid-cols-2 to grid-cols-[1.5fr_1fr] to give title more width -->
     <header class="grid grid-cols-[1.5fr_1fr] gap-5 items-center px-4 py-2 sm:px-5 sm:py-3 md:px-6 md:py-4 lg:px-8 lg:py-6">
      <div class="overflow-hidden">
       <h1 class="text-3xl sm:text-4xl md:text-5xl lg:text-4xl xl:text-6xl font-bold uppercase font-heading lava-gradient-text whitespace-nowrap">
        MRS.WIKD
       </h1>
       <!-- FIX: Reduced lg:text-lg to lg:text-base to prevent clipping -->
       <h2 class="text-base sm:text-lg md:text-xl lg:text-base xl:text-xl uppercase font-heading text-white whitespace-nowrap">
        Bentley Continental GT
       </h2>
      </div>
      <div class="text-right">
       <div class="stats-hp text-3xl sm:text-4xl md:text-5xl lg:text-4xl xl:text-6xl font-bold font-heading whitespace-nowrap" data-target="750" style="color: #FF00A6;">
        0 HP
       </div>
       <div class="stats-tq text-2xl sm:text-3xl md:text-4xl lg:text-3xl xl:text-5xl font-bold font-heading whitespace-nowrap" data-target="700" style="color: var(--color-secondary);">
        0 TQ
       </div>
      </div>
     </header>
     <!-- Divider -->
     <div class="h-1 w-full lava-gradient-bg">
     </div>
     <!-- Main Body Content -->
     <div class="px-4 sm:px-5 md:px-6 lg:px-8 pt-4 sm:pt-6 lg:pb-10">
      <!-- Dyno Section -->
      <section class="anim-stagger">
       <div id="chart-container">
        <canvas id="dynoChart"></canvas>
       </div>
      </section>
      <!-- Specifications & Modifications -->
      <section class="mt-10 anim-stagger">
       <h3 class="text-3xl font-bold uppercase font-heading border-b border-gray-800 pb-2 mb-4">
        Specifications
       </h3>
       <ul class="text-lg">
        <li class="flex justify-between py-3 border-b border-gray-800/50">
         <strong class="text-gray-400 font-medium">
          YEAR
         </strong>
         <span>
          2023
         </span>
        </li>
        <li class="flex justify-between py-3 border-b border-gray-800/50">
         <strong class="text-gray-400 font-medium">
          MAKE
         </strong>
         <span>
          Bentley
         </span>
        </li>
        <li class="flex justify-between py-3 border-b border-gray-800/50">
         <strong class="text-gray-400 font-medium">
          MODEL
         </strong>
         <span>
          Continental GT
         </span>
        </li>
       </ul>
       <div class="mods-section mt-10">
        <h3 class="text-3xl font-bold uppercase font-heading border-b border-gray-800 pb-2 mb-4">
         Modifications
        </h3>
        <div class="mt-4 space-y-6">
         <div>
          <h4 class="text-xl font-semibold uppercase font-heading border-b border-gray-800 pb-2" style="color: #FF00A6;">
           Build List
          </h4>
          <ul class="mt-4 space-y-2 text-gray-300">
           <li>
            WIKD Performance Tune
           </li>
           <li>
            WIKD Exhaust System
           </li>
           <li>
            Custom Forged Wheels
           </li>
          </ul>
         </div>
        </div>
       </div>
      </section>
     </div>
    </main>
   </div>
  </div>
  <!-- Lightbox -->
  <div class="fixed top-0 left-0 w-full h-full bg-black/90 z-50 flex justify-center items-center p-4 opacity-0 pointer-events-none transition-opacity duration-300" id="lightbox">
   <div class="relative max-w-4xl max-h-full">
        <button class="lightbox-close absolute -top-10 right-0 text-white text-4xl transition-colors hover:text-red-500">&times;</button>
    <button class="lightbox-prev absolute left-0 top-1/2 -translate-y-1/2 -ml-12 text-white text-6xl transition-colors hover:text-red-500">&lt;</button>
    <button class="lightbox-next absolute right-0 top-1/2 -translate-y-1/2 -mr-12 text-white text-6xl transition-colors hover:text-red-500">&gt;</button>
    <img alt="Lightbox image" class="max-w-full max-h-[90vh] rounded-lg hidden" id="lightboxImg" src=""/>
    <video class="max-w-full max-h-[90vh] rounded-lg hidden" controls="" id="lightboxVideo" src="">
    </video>
   </div>
  </div>
  <!-- Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js">
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js">
  </script>
  <script>
   document.addEventListener('DOMContentLoaded', function() {
    // --- GLOBAL ELEMENTS & STATE ---
    const contentCard = document.getElementById('contentCard');
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightboxImg');
    const lightboxVideo = document.getElementById('lightboxVideo');

    const originalItems = Array.from(document.querySelectorAll('#tickerInner .image-ticker-card')).map(card => {
        const isVideo = card.querySelector('video');
        if (isVideo) {
            return { type: 'video', src: isVideo.querySelector('source').src };
        } else {
            return { type: 'image', src: card.querySelector('img').src };
        }
    });

    let currentIndex = 0;
    let desktopTickerAnimation;
    let mobileTickerAnimation;
    let isMobile = window.innerWidth < 1024;

    // --- LIGHTBOX LOGIC ---
    const showLightboxItem = (index) => {
      const adjustedIndex = (index + originalItems.length) % originalItems.length;
      const item = originalItems[adjustedIndex];

      // Ensure we don't try to open a video in the lightbox
      if (item.type === 'video') return;

      currentIndex = adjustedIndex;

      lightboxImg.style.display = 'none';
      lightboxVideo.style.display = 'none';
      if (!lightboxVideo.paused) {
          lightboxVideo.pause();
      }
      lightboxVideo.removeAttribute('src');

      if (item.type === 'image') {
        lightboxImg.src = item.src;
        lightboxImg.style.display = 'block';
      }
      lightbox.classList.remove('opacity-0', 'pointer-events-none');
    };

    const setupLightboxListeners = (selector) => {
        document.querySelectorAll(selector).forEach((item, index) => {
          const newItem = item.cloneNode(true);
          item.parentNode.replaceChild(newItem, item);

          newItem.addEventListener('click', (e) => {
            const adjustedIndex = index % originalItems.length;
            const itemData = originalItems[adjustedIndex];

            if (itemData.type === 'image') {
              showLightboxItem(adjustedIndex);
            } else if (isMobile) {
              // On mobile, the div isn't a link, so we trigger navigation via JS
              e.preventDefault();
              window.open('https://www.wikdmotorsports.com/products/mclaren-720s-titanium-catback-2018-brushed-purple', '_blank');
            }
            // On desktop, the video card is an anchor tag, so default browser behavior handles the link.
          });
        });
    }

    const closeLightbox = () => {
        lightbox.classList.add('opacity-0', 'pointer-events-none');
        if (!lightboxVideo.paused) {
            lightboxVideo.pause();
        }
        lightboxVideo.removeAttribute('src');
    };

    if (lightbox) {
      document.querySelector('.lightbox-close').addEventListener('click', closeLightbox);
      document.querySelector('.lightbox-prev').addEventListener('click', () => showLightboxItem(currentIndex - 1));
      document.querySelector('.lightbox-next').addEventListener('click', () => showLightboxItem(currentIndex + 1));
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !lightbox.classList.contains('opacity-0')) {
          closeLightbox();
        }
      });
    }

    // --- MOBILE VIEW SETUP ---
    function setupMobileView() {
        if (desktopTickerAnimation) desktopTickerAnimation.kill();
        const mobileTickerInner = document.getElementById('mobileTickerInner');
        if (mobileTickerInner.children.length > 0) return;

        originalItems.forEach(item => {
            const itemContainer = document.createElement('div');
            itemContainer.className = 'mobile-gallery-item h-full flex-shrink-0 mr-4';
            let mediaElement;
            if (item.type === 'video') {
                mediaElement = document.createElement('video');
                mediaElement.src = item.src;
                mediaElement.autoplay = true;
                mediaElement.loop = true;
                mediaElement.muted = true;
                mediaElement.playsinline = true;
            } else {
                mediaElement = document.createElement('img');
                mediaElement.src = item.src;
            }
            mediaElement.className = 'h-full w-auto object-cover rounded-md';
            itemContainer.appendChild(mediaElement);
            mobileTickerInner.appendChild(itemContainer);
        });

        const items = mobileTickerInner.querySelectorAll('.mobile-gallery-item');
        items.forEach(item => {
            const clone = item.cloneNode(true);
            mobileTickerInner.appendChild(clone);
        });

        setupLightboxListeners('.mobile-gallery-item');
        gsap.set(mobileTickerInner, {x: 0});
        mobileTickerAnimation = gsap.to(mobileTickerInner, { x: '-50%', duration: 40, ease: 'none', repeat: -1 });
        const galleryHeight = document.getElementById('mobileGalleryWrapper').offsetHeight;
        const initialScroll = galleryHeight * 0.85;
        setTimeout(() => window.scrollTo({ top: initialScroll, behavior: 'smooth' }), 100);
    }

    // --- DESKTOP VIEW SETUP ---
    function setupDesktopView() {
        if (mobileTickerAnimation) mobileTickerAnimation.kill();
        const tickerWrapper = document.getElementById('tickerWrapper');
        const tickerInner = document.getElementById('tickerInner');
        if (!tickerWrapper || tickerInner.querySelectorAll('.cloned').length > 0) return;

        const originalTickerItems = tickerInner.querySelectorAll('.image-ticker-card:not(.cloned)');
        originalTickerItems.forEach(item => {
            const clone = item.cloneNode(true);
            clone.classList.add('cloned');
            tickerInner.appendChild(clone);
        });

        const syncHeights = () => { if (contentCard && tickerWrapper) tickerWrapper.style.height = `${contentCard.offsetHeight}px`; };
        syncHeights();
        window.addEventListener('resize', syncHeights);
        const observer = new MutationObserver(syncHeights);
        observer.observe(contentCard, { attributes: true, childList: true, subtree: true });

        let isHovering = false;
        let isTickerLocked = false;
        tickerWrapper.addEventListener('mouseenter', () => isHovering = true);
        tickerWrapper.addEventListener('mouseleave', () => isHovering = false);

        function animateScroll() {
            if (!isHovering && !isTickerLocked && tickerWrapper) {
                tickerWrapper.scrollTop += 0.5;
                if (tickerWrapper.scrollTop >= tickerInner.offsetHeight / 2) tickerWrapper.scrollTop = 0;
            }
            desktopTickerAnimation = requestAnimationFrame(animateScroll);
        }
        animateScroll();
        setupLightboxListeners('.image-ticker-card');

        // --- NEW VIDEO CONTROLS LOGIC (Class-based, Auto-Injected) ---
        const videoCards = document.querySelectorAll('.image-ticker-card');
        
        videoCards.forEach(card => {
            // Check if it's a video card
            const container = card.querySelector('.relative.group');
            if(!container) return;

            const tickerVideo = container.querySelector('video');
            const mediaControls = container.querySelector('.video-controls');
            if (!tickerVideo || !mediaControls) return;

            const muteButton = mediaControls.querySelector('.video-mute-button');
            const lockButton = mediaControls.querySelector('.video-lock-button');
            let controlsTimeout;

            const showControls = () => {
                mediaControls.classList.remove('opacity-0');
                clearTimeout(controlsTimeout);
                controlsTimeout = setTimeout(() => {
                    mediaControls.classList.add('opacity-0');
                }, 2000);
            };

            const hideControls = () => {
                mediaControls.classList.add('opacity-0');
                clearTimeout(controlsTimeout);
            };

            card.addEventListener('mouseenter', showControls);
            card.addEventListener('mousemove', showControls);
            card.addEventListener('mouseleave', hideControls);

            muteButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                tickerVideo.muted = !tickerVideo.muted;
                muteButton.querySelector('i').className = tickerVideo.muted ? 'fas fa-volume-mute' : 'fas fa-volume-high';
            });

            lockButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isTickerLocked = !isTickerLocked;
                // Update all lock buttons
                document.querySelectorAll('.video-lock-button i').forEach(icon => {
                    icon.className = isTickerLocked ? 'fas fa-lock' : 'fas fa-unlock';
                });
            });
        });
    }


    // --- COMMON ANIMATIONS & UI ---
    gsap.registerPlugin(ScrollTrigger);
    gsap.utils.toArray('.anim-stagger').forEach(elem => gsap.from(elem, { scrollTrigger: { trigger: elem, start: 'top 95%', toggleActions: 'play none none none', }, opacity: 0, y: 50, duration: 0.8, ease: 'power3.out' }));
    gsap.utils.toArray('.stats-hp, .stats-tq').forEach(stat => { const target = parseInt(stat.dataset.target, 10); const statObject = { val: 0 }; gsap.to(statObject, { val: target, duration: 2.5, ease: 'power3.out', delay: 0.5, onUpdate: () => { stat.textContent = `${Math.round(statObject.val)} ${stat.classList.contains('stats-hp') ? 'HP' : 'TQ'}`; } }); });
    const dataHeader = document.querySelector('.data-header');
    if(dataHeader) { const dataList = document.querySelector('.data-list-collapsible'); const icon = dataHeader.querySelector('i'); dataHeader.addEventListener('click', () => { const isActive = dataHeader.classList.toggle('active'); dataList.style.maxHeight = isActive ? dataList.scrollHeight + 'px' : '0'; icon.style.transform = isActive ? 'rotate(180deg)' : 'rotate(0deg)'; }); }

    // --- INITIALIZATION & RESIZE HANDLING ---
    function initializePage() { isMobile = window.innerWidth < 1024; if (isMobile) setupMobileView(); else setupDesktopView(); }
    let resizeTimer;
    window.addEventListener('resize', () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(() => { const newIsMobile = window.innerWidth < 1024; if (newIsMobile !== isMobile) window.location.reload(); }, 250); });
    initializePage();

    // --- CHART SCRIPT ---
    const fullChartData = [
        { rpm: 2000, horsepower: 150, torque: 394 }, { rpm: 2500, horsepower: 250, torque: 525 },
        { rpm: 3000, horsepower: 350, torque: 613 }, { rpm: 3500, horsepower: 450, torque: 675 },
        { rpm: 4000, horsepower: 550, torque: 722 }, { rpm: 4500, horsepower: 650, torque: 700 },
        { rpm: 5000, horsepower: 700, torque: 680 }, { rpm: 5500, horsepower: 725, torque: 650 },
        { rpm: 6000, horsepower: 740, torque: 615 }, { rpm: 6500, horsepower: 748, torque: 580 },
        { rpm: 6800, horsepower: 750, torque: 550 }, { rpm: 7000, horsepower: 740, torque: 525 },
    ];
    const chartData = fullChartData;
    const peakHpIndex = chartData.findIndex(d => d.horsepower === 882.59);
    const peakTqIndex = chartData.findIndex(d => d.rpm === 5200);
    const peakHpData = new Array(chartData.length).fill(null); if (peakHpIndex !== -1) peakHpData[peakHpIndex] = chartData[peakHpIndex].horsepower;
    const peakTqData = new Array(chartData.length).fill(null); if (peakTqIndex !== -1) peakTqData[peakTqIndex] = chartData[peakTqIndex].torque;
    const fullBorderPlugin = { id: 'fullBorder', afterDraw: (chart) => { const { ctx, chartArea: { left, top, width, height } } = chart; ctx.save(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.lineWidth = 1; ctx.strokeRect(left, top, width, height); ctx.restore(); } };
    const chartCanvas = document.getElementById('dynoChart');
    if (chartCanvas) {
      const initChart = () => {
      const chartContainer = document.getElementById('chart-container'); const overlayCanvas = document.createElement('canvas'); overlayCanvas.style.position = 'absolute'; overlayCanvas.style.top = '0'; overlayCanvas.style.left = '0'; overlayCanvas.style.pointerEvents = 'none'; chartContainer.appendChild(overlayCanvas); const overlayCtx = overlayCanvas.getContext('2d');
      let hpPoint, tqPoint, hpPathPoints, tqPathPoints, allHpPoints;
      function syncOverlay(chart) {
        overlayCanvas.width = chart.width;
        overlayCanvas.height = chart.height;
        overlayCanvas.style.width = chart.width + 'px';
        overlayCanvas.style.height = chart.height + 'px';

        // FIX: Ensure chartArea exists before accessing properties
        if (!chart.chartArea) return;

        const hpMeta = chart.getDatasetMeta(2);
        const tqMeta = chart.getDatasetMeta(3);
        const fullHpMeta = chart.getDatasetMeta(0);
        allHpPoints = fullHpMeta.data;
        if (peakHpIndex !== -1 && hpMeta.data[peakHpIndex]) { hpPoint = hpMeta.data[peakHpIndex]; hpPathPoints = fullHpMeta.data.slice(0, peakHpIndex + 1); }
        if (peakTqIndex !== -1 && tqMeta.data[peakTqIndex]) { tqPoint = tqMeta.data[peakTqIndex]; tqPathPoints = chart.getDatasetMeta(1).data.slice(0, peakTqIndex + 1); }
      }
      function getPointOnPath(path, progress) { if (!path || path.length < 2) return null; const lengths = []; let totalLength = 0; for (let i = 1; i < path.length; i++) { const p1 = path[i - 1], p2 = path[i]; const dx = p2.x - p1.x, dy = p2.y - p1.y; const length = Math.sqrt(dx * dx + dy * dy); lengths.push(length); totalLength += length; } if (totalLength === 0) return path.length > 0 ? { x: path[0].x, y: path[0].y } : null; const targetLength = totalLength * progress; let lengthTraversed = 0; for (let i = 0; i < lengths.length; i++) { const segmentLength = lengths[i]; if (lengthTraversed + segmentLength >= targetLength) { const p1 = path[i], p2 = path[i + 1]; if (segmentLength === 0) return { x: p1.x, y: p1.y }; const segmentProgress = (targetLength - lengthTraversed) / segmentLength; const x = p1.x + (p2.x - p1.x) * segmentProgress; const y = p1.y + (p2.y - p1.y) * segmentProgress; return { x, y }; } lengthTraversed += segmentLength; } return { x: path[path.length - 1].x, y: path[path.length - 1].y }; }
      new Chart(chartCanvas, {
        type: 'line',
        data: {
          labels: chartData.map(d => d.rpm),
          datasets: [
            { label: 'Horsepower (WHP)', data: chartData.map(d => d.horsepower), borderColor: '#FF00A6', borderWidth: 2, pointRadius: 0, yAxisID: 'y', tension: 0.4, order: 1, segment: { borderColor: ctx => (peakHpIndex !== -1 && ctx.p1DataIndex > peakHpIndex) ? '#555555' : undefined, borderDash: ctx => (peakHpIndex !== -1 && ctx.p1DataIndex > peakHpIndex) ? [5, 5] : undefined, } },
            { label: 'Torque (lb-ft)', data: chartData.map(d => d.torque), borderColor: '#FF4DBC', borderWidth: 2, pointRadius: 0, yAxisID: 'y', tension: 0.4, order: 1, segment: { borderColor: ctx => (peakTqIndex !== -1 && ctx.p1DataIndex > peakTqIndex) ? '#555555' : undefined, borderDash: ctx => (peakTqIndex !== -1 && ctx.p1DataIndex > peakTqIndex) ? [5, 5] : undefined, } },
            { label: 'Peak HP', data: peakHpData, pointStyle: 'triangle', pointRadius: 6, pointBackgroundColor: '#FF00A6', yAxisID: 'y', showLine: false, order: 0, },
            { label: 'Peak TQ', data: peakTqData, pointStyle: 'rect', pointRadius: 6, pointBackgroundColor: '#FF4DBC', yAxisID: 'y', showLine: false, order: 0, }
          ]
        },
        options: {
          animation: {
            onComplete: (animation) => { const chartInstance = animation.chart; syncOverlay(chartInstance); if (chartInstance.pingAnimationId) cancelAnimationFrame(chartInstance.pingAnimationId); let startTime = 0; const duration = 5000; const waves = 3; const maxRadius = 12; const easeOutQuint = (t) => 1 - Math.pow(1 - t, 5); function animatePing(timestamp) { if (!startTime) startTime = timestamp; const progress = ((timestamp - startTime) % duration) / duration; overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); overlayCtx.save(); const hpPulsePos = getPointOnPath(hpPathPoints, progress); const tqPulsePos = getPointOnPath(tqPathPoints, progress); if (hpPulsePos && isFinite(hpPulsePos.x) && isFinite(hpPulsePos.y)) { overlayCtx.beginPath(); const hpGradient = overlayCtx.createRadialGradient(hpPulsePos.x, hpPulsePos.y, 0, hpPulsePos.x, hpPulsePos.y, 5); hpGradient.addColorStop(0, 'rgba(255, 0, 166, 0.7)'); hpGradient.addColorStop(1, 'rgba(255, 0, 166, 0)'); overlayCtx.fillStyle = hpGradient; overlayCtx.arc(hpPulsePos.x, hpPulsePos.y, 5, 0, 2 * Math.PI); overlayCtx.fill(); } if (tqPulsePos && isFinite(tqPulsePos.x) && isFinite(tqPulsePos.y)) { overlayCtx.beginPath(); const tqGradient = overlayCtx.createRadialGradient(tqPulsePos.x, tqPulsePos.y, 0, tqPulsePos.x, tqPulsePos.y, 5); tqGradient.addColorStop(0, 'rgba(255, 77, 188, 0.7)'); tqGradient.addColorStop(1, 'rgba(255, 77, 188, 0)'); overlayCtx.fillStyle = tqGradient; overlayCtx.arc(tqPulsePos.x, tqPulsePos.y, 5, 0, 2 * Math.PI); overlayCtx.fill(); } overlayCtx.lineWidth = 2; for (let i = 0; i < waves; i++) { const waveProgress = (progress - (i / waves) + 1) % 1; const easedProgress = easeOutQuint(waveProgress); const pingGap = maxRadius * easedProgress; const alpha = 1 - easedProgress; if (hpPoint && !hpPoint.hidden) { const markerCircumradius = hpPoint.options.radius, pingCircumradius = markerCircumradius + pingGap; overlayCtx.strokeStyle = `rgba(255, 0, 166, ${alpha})`; overlayCtx.beginPath(); const angle = -Math.PI / 2; overlayCtx.moveTo(hpPoint.x + pingCircumradius * Math.cos(angle), hpPoint.y + pingCircumradius * Math.sin(angle)); overlayCtx.lineTo(hpPoint.x + pingCircumradius * Math.cos(angle + 2 * Math.PI / 3), hpPoint.y + pingCircumradius * Math.sin(angle + 2 * Math.PI / 3)); overlayCtx.lineTo(hpPoint.x + pingCircumradius * Math.cos(angle + 4 * Math.PI / 3), hpPoint.y + pingCircumradius * Math.sin(angle + 4 * Math.PI / 3)); overlayCtx.closePath(); overlayCtx.stroke(); } if (tqPoint && !tqPoint.hidden) { const scaledPingGap = pingGap * 0.60, markerRadius = tqPoint.options.radius, pingSideRadius = markerRadius + scaledPingGap; overlayCtx.strokeStyle = `rgba(255, 77, 188, ${alpha})`; const size = pingSideRadius * 2; overlayCtx.strokeRect(tqPoint.x - pingSideRadius, tqPoint.y - pingSideRadius, size, size); } } overlayCtx.restore(); chartInstance.pingAnimationId = requestAnimationFrame(animatePing); } animatePing(performance.now()); },
            x: { type: 'number', easing: 'linear', duration: 50, from: NaN, delay(ctx) { if (ctx.type !== 'data' || ctx.xStarted) return 0; ctx.xStarted = true; return ctx.index * 50; } },
            y: {
                type: 'number',
                easing: 'linear',
                duration: 50,
                from: (ctx) => {
                    // CRITICAL FIX: Skip animation for datasets 2 and 3 (Peak Markers) to prevent crashes
                    if (ctx.datasetIndex > 1) return undefined;

                    if (ctx.index === 0) return ctx.chart.scales.y.getBasePixel();

                    // Safe access to previous point's data
                    const datasetMeta = ctx.chart.getDatasetMeta(ctx.datasetIndex);
                    const prevModel = datasetMeta.data[ctx.index - 1];

                    if (prevModel && !prevModel.skip && !isNaN(prevModel.getProps(['y'], true).y)) {
                         return prevModel.getProps(['y'], true).y;
                    }
                    return ctx.chart.scales.y.getBasePixel();
                },
                delay(ctx) { if (ctx.type !== 'data' || ctx.yStarted) return 0; ctx.yStarted = true; return ctx.index * 50; }
            }
          },
          onResize: (chart) => { syncOverlay(chart); },
          responsive: true, maintainAspectRatio: true, aspectRatio: 1.5,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: { display: false, },
            tooltip: { backgroundColor: 'rgba(31, 31, 31, 0.9)', borderColor: '#2A2A2A', borderWidth: 1, titleFont: { weight: 'bold' }, bodySpacing: 4, padding: 10, callbacks: { title: (context) => `RPM: ${context[0].label}` } }
          },
          scales: {
            x: {
                grid: {
                    color: 'rgba(255, 255, 255, 0.1)',
                    drawTicks: false
                },
                ticks: {
                    color: '#a1a1aa',
                    autoSkip: false, // FORCE all ticks to render so we can filter/pick the last one manually
                    maxRotation: 0,
                    callback: function(val, index, ticks) {
                        // FIX: 'val' for category axis is the index of the data point.
                        // Check if it's the first (0) or last data point index.
                        const totalLabels = this.chart.data.labels.length;
                        if (val === 0 || val === totalLabels - 1) {
                            const tickValue = this.getLabelForValue(val);
                            return `${(tickValue / 1000).toFixed(1).replace('.0', '')}k`;
                        }
                        return '';
                    }
                },
                afterBuildTicks: axis => {
                    // Manually filter ticks to keep grid lines manageable but ensure first/last exist
                    const dataLength = axis.chart.data.labels.length;
                    const step = Math.ceil(dataLength / 10);
                    axis.ticks = axis.ticks.filter(tick => {
                        const val = tick.value;
                        return val === 0 || val === dataLength - 1 || val % step === 0;
                    });
                }
            },
            y: {
                type: 'linear',
                position: 'left',
                grid: {
                    color: 'rgba(255, 255, 255, 0.1)',
                    drawTicks: false // Contained grid
                },
                ticks: {
                    color: '#a1a1aa',
                    callback: function(val, index, ticks) {
                        // Only show min and max
                        if (index === 0 || index === ticks.length - 1) {
                            return val;
                        }
                        return '';
                    }
                },
                min: 0,
                max: 1000,
                title: { display: false } // No title
            }
          }
        },
        plugins: [fullBorderPlugin]
      });
      };

      if (window.IntersectionObserver) {
        const observer = new IntersectionObserver((entries) => {
          if (entries[0].isIntersecting) {
            initChart();
            observer.disconnect();
          }
        }, { rootMargin: '0px 0px 100px 0px' });
        observer.observe(chartCanvas);
      } else {
        initChart();
      }
    }
  });
  </script>
 </body>
</html>
